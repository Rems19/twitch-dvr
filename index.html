<html>
    <head>
    <style>
        #player-container {
            width: 1280px;
            height: 720px;
            position: relative;
            background-color: black;
        }

        video {
            position: absolute;
        }

        #fullscreen, #play, #pause, #volume-container {
            bottom: 20px;
            height: 20px;
        }

        .control {
            position: absolute;
            cursor: pointer;
        }

        #controls {
            position: absolute;
            bottom: 0;
            height: 60px;
            width: 100%;
            background-color: rgba(0, 0, 0, 0.2);
            font-size: 10px;
            line-height: 10px;
            font-weight: 600;
            font-family: sans-serif;
        }

        #volume {
            bottom: 21px;
        }

        #volume-container {
            width: 115px;
            overflow: hidden;
            left: 80px;
        }

        #volume-empty, #volume-slider, #volume-filled, #volume-handle {
            pointer-events: none;
        }

        #volume-empty {
            height: 2px;
            border: 1px solid rgba(0, 0, 0, .2);
            background-color: rgba(255, 255, 255, .2);
            width: 100%;
            left: 0;
            top: 8px;
        }

        #volume-slider {
            width: 60px;
        }

        #volume-filled {
            top: 9px;
            height: 2px;
            width: 95%;
            background-color: white;
        }

        #volume-handle {
            background-color: white;
            border-radius: 7px;
            border: 0.5px solid rgba(0, 0, 0, .2);
            right: 0.5px;
            top: 2.5px;
            width: 14px;
            height: 14px;
        }

        #fullscreen {
            right: 20px;
        }

        #play, #pause {
            left: 20px;
        }

        #play {
            display: none;
        }

        #volume {
            left: 60px;
        }

        #quality {
            bottom: 20px;
            height: 20px;
            right: 60px;
            box-sizing: border-box;
            padding: 4px 6px;
            border: 1px solid rgba(0, 0, 0, 0.2);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 9px;
        }

        #quality-picker {
            bottom: 42px;
            right: 60px;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 6px 0;
            border-radius: 2px;
        }

        .picker {
            text-align: right;
            padding: 4px 7.5px;
        }

        .picker:hover {
            background-color: rgba(255, 255, 255, .2);
        }
    </style>
    </head>
    <body>
        <div id="player-container">
            <video id="player" width="100%" height="100%" playsinline></video>
            <div id="controls">
                <div id="play" class="control" onclick="play()">
                    <svg width="16" height="20" viewBox="0 0 16 20" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M1 19V1L15 10L1 19Z" fill="white"/>
                    <path d="M1.27038 0.579411C1.11652 0.480504 0.920943 0.473499 0.760406 0.561144C0.599869 0.648789 0.5 0.817096 0.5 1V19C0.5 19.1829 0.599869 19.3512 0.760406 19.4389C0.920943 19.5265 1.11652 19.5195 1.27038 19.4206L15.2704 10.4206C15.4135 10.3286 15.5 10.1701 15.5 10C15.5 9.82987 15.4135 9.67141 15.2704 9.57941L1.27038 0.579411Z" stroke="black" stroke-opacity="0.2" stroke-linejoin="round"/>
                    </svg>
                </div>
                <div id="pause" class="control" onclick="pause()">
                    <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M1 1H7V19H1V1Z" fill="white"/>
                    <path d="M13 1H19V19H13V1Z" fill="white"/>
                    <path d="M1 0.5H0.5V1V19V19.5H1H7H7.5V19V1V0.5H7H1ZM13 0.5H12.5V1V19V19.5H13H19H19.5V19V1V0.5H19H13Z" stroke="black" stroke-opacity="0.2"/>
                    </svg>
                </div>
                <div id="volume" class="control">
                    <svg width="11" height="18" viewBox="0 0 11 18" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M1 6V12H5L10 17V1L5 6H1Z" fill="white"/>
                    <path d="M0.5 12C0.5 12.2761 0.723858 12.5 1 12.5H4.79289L9.64645 17.3536C9.78945 17.4966 10.0045 17.5393 10.1913 17.4619C10.3782 17.3846 10.5 17.2022 10.5 17V1C10.5 0.797769 10.3782 0.615451 10.1913 0.53806C10.0045 0.46067 9.78945 0.503448 9.64645 0.646447L4.79289 5.5H1C0.723858 5.5 0.5 5.72386 0.5 6V12Z" stroke="black" stroke-opacity="0.2" stroke-linejoin="round"/>
                    </svg>
                </div>
                <div id="volume-container" class="control">
                    <div id="volume-empty" class="control"></div>
                    <div id="volume-slider" class="control">
                        <div id="volume-filled" class="control"></div>
                        <div id="volume-handle" class="control"></div>
                    </div>
                </div>
                <div id="quality-picker" class="control"></div>
                <div id="quality" class="control" onclick="togglePicker()"></div>
                <div id="fullscreen" class="control" onclick="toggleFullscreen()">
                    <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M19 19V13H17V17H13V19H19Z" fill="white"/>
                    <path d="M19 1V7H17V3H13V1H19Z" fill="white"/>
                    <path d="M1 1V7H3V3H7V1H1Z" fill="white"/>
                    <path d="M1 13V19H7V17H3V13H1Z" fill="white"/>
                    <path d="M1 12.5H0.5V13V19V19.5H1H7H7.5V19V17V16.5H7H3.5V13V12.5H3H1ZM19.5 13V12.5H19H17H16.5V13V16.5H13H12.5V17V19V19.5H13H19H19.5V19V13ZM19 7.5H19.5V7V1V0.5H19H13H12.5V1V3V3.5H13H16.5V7V7.5H17H19ZM0.5 7V7.5H1H3H3.5V7V3.5H7H7.5V3V1V0.5H7H1H0.5V1V7Z" stroke="black" stroke-opacity="0.2"/>
                    </svg>
                </div>
            </div>
        </div>
        <script>
const mediaSrc = new MediaSource();
const url = URL.createObjectURL(mediaSrc);
let sourceBuffer = null;
let arrayOfBlobs = [];
let player = null;
let generation = 0;

function toggleFullscreen() {
    if (
        document.fullscreenElement ||
        document.webkitFullscreenElement ||
        document.mozFullScreenElement ||
        document.msFullscreenElement
    ) {
        if (document.exitFullscreen) {
            document.exitFullscreen();
        } else if (document.mozCancelFullScreen) {
            document.mozCancelFullScreen();
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }
    } else {
        const element = document.getElementById("player-container");
        if (element.requestFullscreen) {
            element.requestFullscreen();
        } else if (element.mozRequestFullScreen) {
            element.mozRequestFullScreen();
        } else if (element.webkitRequestFullscreen) {
            element.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
        } else if (element.msRequestFullscreen) {
            element.msRequestFullscreen();
        }
    }
}

async function parseVODM3U8(url) {
    const urlParts = url.split("/");
    urlParts.pop();
    const baseUrl = urlParts.join("/");

    const resp = await fetch(url);
    const m3u8 = await resp.text();
    const segments = [];

    const lines = m3u8.split("\n");
    for (let i = 0; i < lines.length - 1; i++) {
        const line = lines[i];
        if (line.substring(0, 8) === "#EXTINF:") {
            segments.push({ 
                url: new URL(`${baseUrl}/${lines[i+1]}`)
            });
        }
    }

    return segments;
}

let lastFetched = new Set();

async function bufferLive(url, startGeneration) {
    const resp = await fetch(url);
    const m3u8 = await resp.text();
    const segments = [];
    const fetched = new Set();

    const skipSegments = lastFetched.size === 0 ? 15 : 0;

    const lines = m3u8.split("\n");
    let skipped = 0;
    for (let i = 0; i < lines.length - 1; i++) {
        if (generation !== startGeneration) break;

        const line = lines[i];
        let segment = null;
        if (line.substring(0, 8) === "#EXTINF:") {
            segment = lines[i+1];
        } else if (line.substring(0, 23) === "#EXT-X-TWITCH-PREFETCH:") {
            segment = line.substring(23);
        }

        if (segment) {
            fetched.add(segment);

            if (skipped < skipSegments) {
                skipped++;
                continue;
            }

            if (!lastFetched.has(segment)) {
                const resp = await fetch(segment);
                arrayOfBlobs.push(await resp.arrayBuffer());
                if (generation === startGeneration) {
                    appendToSourceBuffer();
                }
            }
        }
    }

    lastFetched = fetched;
}

function parseMasterManifest(m3u8) {
    const lines = m3u8.split("\n");
    const variants = [];
    for (let i = 0; i < lines.length - 1; i++) {
        const line = lines[i];
        if (line.substring(0, 18) === "#EXT-X-STREAM-INF:") {
            const parts = line.substring(18).split(",");
            const variant = {};
            for (let j = 0; j < parts.length; j++) {
                const part = parts[j];
                const vals = part.split('=');
                switch (vals[0]) {
                    case "BANDWIDTH":
                        variant.bandwidth = parseInt(vals[1]);
                        break;
                    case "RESOLUTION":
                        variant.resolution = `${vals[1].split('x')[1]}p`;
                        break;
                    case "CODECS":
                        variant.codecs = `${vals[1]},${parts[j+1]}`;
                        break;
                    case "VIDEO":
                        variant.name = vals[1];
                        break;
                    case "FRAME-RATE":
                        variant.framerate = Math.ceil(parseFloat(vals[1]));
                        break;
                }
            }
            if (variant.framerate !== 30) {
                variant.resolution += variant.framerate;
            }
            variant.url = lines[i+1];
            const picker = document.createElement("div");
            picker.className = "picker";
            picker.innerText = variant.resolution;
            const idx = variants.length;
            picker.addEventListener("click", () => {
                setVariant(idx);
            });
            document.getElementById("quality-picker").appendChild(picker);
            variants.push(variant);
        }
    }

    return variants;
}

async function getLiveM3U8(channel) {
    let resp = await fetch(`http://localhost/api/channels/${channel}/access_token`, {
        headers: {
            'client-id': 'kimne78kx3ncx6brgo4mv6wki5h1ko',
        },
    });

    const json = await resp.json();
    const token = json.token;
    const sig = json.sig;

    resp = await fetch(`http://localhost/api/channel/hls/${channel}.m3u8?allow_source=true&fast_bread=true&playlist_include_framerate=true&reassignments_supported=true&sig=${sig}&token=${encodeURI(token)}`);
    const text = await resp.text();

    const parsed = parseMasterManifest(text);
    return parsed;
}

let paused = true;
let firstTime = true;

async function appendToSourceBuffer() {
    if (!sourceBuffer) return;

    if (mediaSrc.readyState === "open" && sourceBuffer && sourceBuffer.updating === false && arrayOfBlobs.length > 0) {
        const blob = arrayOfBlobs.shift();
        sourceBuffer.appendBuffer(blob);
    }

    if (firstTime && sourceBuffer.buffered.length) {
        player.currentTime = sourceBuffer.buffered.start(0);
        player.play();
        firstTime = false;
    }

    const bufferLimit = 200;
    if (player.buffered.length && player.buffered.end(0) - player.buffered.start(0) > bufferLimit) {
        sourceBuffer.remove(player.buffered.start(0), player.buffered.end(0) - bufferLimit);
    }
}

let rebufferTimer = null;
let variant = {};
const budget = 2000;
let budgetEnd = 0;
let variants = [];

function pause() {
    document.getElementById("pause").style.display = "none";
    document.getElementById("play").style.display = "block";
    sourceBuffer.abort();
    sourceBuffer.remove(sourceBuffer.buffered.start(0), sourceBuffer.buffered.end(0));
    if (rebufferTimer) {
        clearTimeout(rebufferTimer);
        rebufferTimer = null;
        arrayOfBlobs = [];
    }
    paused = true;
    generation++;
}

function play() {
    document.getElementById("play").style.display = "none";
    document.getElementById("pause").style.display = "block";
    if (paused) {
        rebuffer();
        paused = false;
        firstTime = true;
    }
}

function togglePicker() {
    const picker = document.getElementById("quality-picker");
    picker.style.display = picker.style.display === "block" ? "none" : "block";
}

let bufferPromise = null;

const rebuffer = async function() {
    const startGeneration = generation;
    console.log('rebuffering');
    budgetEnd += budget;

    if (bufferPromise) await bufferPromise;

    bufferPromise = bufferLive(variant.url, startGeneration);
    console.log('hello');
    const remaining = Math.max(0, budgetEnd - Date.now());
    if (remaining === 0) budgetEnd = Date.now();
    if (generation === startGeneration) {
        rebufferTimer = setTimeout(rebuffer, remaining);
    }
};

const volume = document.getElementById("volume-slider");

function setVolume(vol) {
    vol = Math.min(1, Math.max(0, vol));
    player.volume = vol;
    volume.style.width = `${vol * 100 + 15.5}px`;
}

function setVariant(idx) {
    document.getElementById("quality-picker").style.display = "none";
    variant = variants[idx];
    if (sourceBuffer) {
        if (!paused) pause();
        lastFetched = new Set();
    } else {
        mediaSrc.addEventListener("sourceopen", function() {
            sourceBuffer = mediaSrc.addSourceBuffer(`video/mp2t; codecs=${variant.codecs}`);
            sourceBuffer.addEventListener("updateend", appendToSourceBuffer);
            sourceBuffer.addEventListener("error", (buffer, ev) => {
                debugger;
            });
        });
    }

    document.getElementById("quality").innerText = variant.resolution;
    budgetEnd = Date.now() + budget;
    play();
}

async function main() {
    player = document.getElementById("player");

    variants = await getLiveM3U8('numotthenummy');
    setVariant(0);
    player.src = url;
    setVolume(player.volume);

    const volumeContainer = document.getElementById("volume-container");
    volumeContainer.addEventListener("mousedown", (ev) => {
        let leftSide = ev.pageX - ev.offsetX;
        setVolume((ev.offsetX - 7.5) / 100);

        const mouseMove = (ev) => {
           setVolume((ev.pageX - leftSide - 7.5) / 100);
        }
        const mouseUp = (ev) => {
            document.removeEventListener("mousemove", mouseMove);
            document.removeEventListener("mouseUp", mouseUp);
        }
        document.addEventListener("mousemove", mouseMove);
        document.addEventListener("mouseup", mouseUp);
    });
}

main();

        </script>
    </body>
</html>